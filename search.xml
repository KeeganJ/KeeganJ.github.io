<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/articles/2020-06-10-hashCode/"/>
      <url>/articles/2020-06-10-hashCode/</url>
      
        <content type="html"><![CDATA["use strict";// hashCode.tsexports.__esModule = true;function hashCode(str) {    var hash = 0;    if (str.length == 0)        return hash;    for (var i = 0; i < str.length; i++) {        var char = str.charCodeAt(i);        hash = ((hash << 5) - hash) + char;        hash = hash & hash; // Convert to 32bit integer    }    return hash;}exports["default"] = hashCode;]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Type Guessing</title>
      <link href="/articles/2020-06-10-type-guessing/"/>
      <url>/articles/2020-06-10-type-guessing/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.prototype.hashCode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.length == <span class="number">0</span>) <span class="keyword">return</span> hash;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">char = <span class="keyword">this</span>.charCodeAt(i);</span><br><span class="line">hash = ((hash&lt;&lt;<span class="number">5</span>)-hash)+char;</span><br><span class="line">hash = hash &amp; hash; <span class="comment">// Convert to 32bit integer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>I frequently find myself converting javascript files to typescript. Whether it’s modifying code snippets like the above or annotating entire JS codebases, adding types to existing JS code is an ongoing process.</p><p>Despite this, the most oft-repeated advice for <em>how</em> to perform a transition to typescript looks like this:</p><ol><li>Convert the file extension from <code>.js</code> to <code>.ts</code></li><li>Try to compile</li><li>Fix the compilation errors</li></ol><p>This is good advice for getting started, but is almost never the whole story in my experience. Simply changing the extension adds basic type inference, but rarely <em>enforces</em> any types effectively, which is most of the benefit gained from adding typescript in the first place.</p><p>On the flipside, adding types to every variable declaration and assignment is an enourmous chore, and rarely worth the effort. It can add clutter to previously readable code and takes no advantage of typescript’s wonderful type inference system. It also creates more work for both yourself and anyone else that plans on modifying the code later on.</p><p>Like most things in life, I’ve found the best cost/benefit tradeoff is somewhere between these two approaches. I find it best to add types in these three places:</p><ol><li>Function signitures (input and output types)</li><li>Returned objects from untyped libraries or method calls</li><li>Any time I use <code>let</code> rather than <code>const</code> for a variable declaration.</li></ol><p>I’ve loosely come to call this process “Type Guessing”, since the addition of these types to existing code (especially when it’s considered legacy) involves some educated guesswork.</p><p>Below I’ll summarize some of my experience in converting methods, files, and codebases to typescript. It’s probably not the most efficient process, but it is consistent, and brings more of the benefits of TS to your existing code than simply changing the file extension.</p><h2 id="An-Example"><a href="#An-Example" class="headerlink" title="An Example"></a>An Example</h2><p>As an example, we’ll use the following hash code function, courtesy of “wes” of the Manwe blog. It’s an excellent piece of code with some non-trivial types:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.prototype.hashCode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.length == <span class="number">0</span>) <span class="keyword">return</span> hash;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">char = <span class="keyword">this</span>.charCodeAt(i);</span><br><span class="line">hash = ((hash&lt;&lt;<span class="number">5</span>)-hash)+char;</span><br><span class="line">hash = hash &amp; hash; <span class="comment">// Convert to 32bit integer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Since we’re using this as an example, we’ll put this in its own file and make it the default exported function rather than an addition to the string prototype:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashCode.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">hashCode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (str.length == <span class="number">0</span>) <span class="keyword">return</span> hash;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">char = str.charCodeAt(i);</span><br><span class="line">hash = ((hash&lt;&lt;<span class="number">5</span>)-hash)+char;</span><br><span class="line">hash = hash &amp; hash;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-1-Change-the-extension"><a href="#Step-1-Change-the-extension" class="headerlink" title="Step 1: Change the extension"></a>Step 1: Change the extension</h2><p>As mentioned in the intro, the first step is to simply change the extension on the file. If you’re using an editor that compiles / checks your TS automatically, this is probably the point that you’ll start seeing those red underlines that let you know something is wrong. In this tutorial we’ll use the typescript compiler:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ tsc hashCode.ts </span><br><span class="line">hashCode.ts:4:7 - error TS2304: Cannot find name <span class="string">'i'</span>.</span><br><span class="line"></span><br><span class="line">4  <span class="keyword">for</span> (i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">        ~</span><br><span class="line"></span><br><span class="line">hashCode.ts:4:14 - error TS2304: Cannot find name <span class="string">'i'</span>.</span><br><span class="line"></span><br><span class="line">4  <span class="keyword">for</span> (i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">               ~</span><br><span class="line"></span><br><span class="line">hashCode.ts:4:30 - error TS2304: Cannot find name <span class="string">'i'</span>.</span><br><span class="line"></span><br><span class="line">4  <span class="keyword">for</span> (i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">                               ~</span><br><span class="line"></span><br><span class="line">hashCode.ts:5:3 - error TS2304: Cannot find name <span class="string">'char'</span>.</span><br><span class="line"></span><br><span class="line">5       char = str.charCodeAt(i);</span><br><span class="line">        ~~~~</span><br><span class="line"></span><br><span class="line">hashCode.ts:5:25 - error TS2304: Cannot find name <span class="string">'i'</span>.</span><br><span class="line"></span><br><span class="line">5       char = str.charCodeAt(i);</span><br><span class="line">                              ~</span><br><span class="line"></span><br><span class="line">hashCode.ts:6:27 - error TS2304: Cannot find name <span class="string">'char'</span>.</span><br><span class="line"></span><br><span class="line">6       <span class="built_in">hash</span> = ((<span class="built_in">hash</span>&lt;&lt;5)-<span class="built_in">hash</span>)+char;</span><br><span class="line">                                ~~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found 6 errors.</span><br></pre></td></tr></table></figure><p>All of these issues look like they stem from undeclared variables. We can fix this simply by adding a <code>let</code> in front of the <code>i</code> in the for loop and <code>const</code> in front of <code>char</code>:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashCode.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">hashCode</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (str.length == <span class="number">0</span>) <span class="keyword">return</span> hash;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line"><span class="keyword">const</span> char = str.charCodeAt(i);</span><br><span class="line">hash = ((hash&lt;&lt;<span class="number">5</span>)-hash)+char;</span><br><span class="line">hash = hash &amp; hash; <span class="comment">// Convert to 32bit integer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And now we’re building without errors! At this point we can already see some benefits:</p><ol><li>We can use this file in other typescript code without warnings.</li><li>The return type of the method is inferred to be <code>number</code>, since typescript can infer that from the existing statements.</li></ol><h2 id="Step-2-Function-signatures"><a href="#Step-2-Function-signatures" class="headerlink" title="Step 2: Function signatures"></a>Step 2: Function signatures</h2><p>The above types that we got without adding any annotations are the result of a process called “type inferece”. You can read more about it in the <a href="https://www.typescriptlang.org/docs/handbook/type-inference.html" target="_blank" rel="noopener">Typescript handbook</a>, but in short it’s the process the compiler uses to deduce the underlying types of variables by the ways in which they are assigned and used.</p><p>Here, Typescript was able to deduce that <code>hash</code> is a number because it knows the initial assignment on line 3 and the operations on lines 8 and 9 will result in a number. However, it <em>can’t</em> know what the type of the argument <code>str</code> is, because the caller of this function could pass anything to this function. This is where explicit typing comes in useful.</p><p>In general, I find spending the type to explicitly add types to function signatures is almost always worth the time and effort. It serves as a natural checkpoint for any potential problems in your call chain, and it ensures that any function in a typescript file starts with clearly defined types (rather than letting the <code>any</code> type cascade through the function implementation).</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashCode.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">hashCode</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line"><span class="keyword">let</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (str.length == <span class="number">0</span>) <span class="keyword">return</span> hash;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line"><span class="keyword">const</span> char = str.charCodeAt(i);</span><br><span class="line">hash = ((hash&lt;&lt;<span class="number">5</span>)-hash)+char;</span><br><span class="line">hash = hash &amp; hash; <span class="comment">// Convert to 32bit integer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-3-Variable-declarations"><a href="#Step-3-Variable-declarations" class="headerlink" title="Step 3: Variable declarations"></a>Step 3: Variable declarations</h2><p>Even though <code>hash</code> is inferred to be a number, I believe it’s still worthwhile to explicitly declare it so. Because let variables can be reassigned, and because javascript has no problem with assigning a value with a different type to an existing variable, explicitly declaring the type adds a safety rail to any modifications you or another developer makes to this file in the future. Plus, because these declaration lines are typically short, this is a location where adding a type probably adds to the readability of your code rather than cluttering it.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashCode.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">hashCode</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line"><span class="keyword">let</span> hash: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (str.length == <span class="number">0</span>) <span class="keyword">return</span> hash;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line"><span class="keyword">const</span> char = str.charCodeAt(i);</span><br><span class="line">hash = ((hash&lt;&lt;<span class="number">5</span>)-hash)+char;</span><br><span class="line">hash = hash &amp; hash; <span class="comment">// Convert to 32bit integer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Estimating Large Table Counts in Postgres</title>
      <link href="/articles/2019-02-26-Estimating-Large-Table-Counts-In-Postgres/"/>
      <url>/articles/2019-02-26-Estimating-Large-Table-Counts-In-Postgres/</url>
      
        <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- count_estimate.sql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> count_estimate(<span class="keyword">query</span> <span class="built_in">text</span>) <span class="keyword">RETURNS</span> <span class="built_in">integer</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  rec   <span class="built_in">record</span>;</span><br><span class="line">  rows  integer;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">FOR</span> rec <span class="keyword">IN</span> <span class="keyword">EXECUTE</span> <span class="string">'EXPLAIN '</span> || <span class="keyword">query</span> <span class="keyword">LOOP</span></span><br><span class="line">    <span class="keyword">rows</span> := <span class="keyword">substring</span>(rec.<span class="string">"QUERY PLAN"</span> <span class="keyword">FROM</span> <span class="string">' rows=([[:digit:]]+)'</span>);</span><br><span class="line">    EXIT WHEN rows IS NOT NULL;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">  RETURN rows;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql VOLATILE STRICT;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Testing --</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Control</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> large_table <span class="keyword">WHERE</span> condition; </span><br><span class="line"><span class="comment">-- 52,652,307 -- 1m:24s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Experimental</span></span><br><span class="line"><span class="keyword">SELECT</span> count_estimate(</span><br><span class="line">  <span class="string">'SELECT * FROM large_table WHERE condition'</span></span><br><span class="line">); </span><br><span class="line"><span class="comment">-- 52,234,432 -- 0m:00.081s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 0.8%      difference in result</span></span><br><span class="line"><span class="comment">-- 103,704%  difference in runtime</span></span><br></pre></td></tr></table></figure><h2 id="For-the-Want-of-a-COUNT"><a href="#For-the-Want-of-a-COUNT" class="headerlink" title="For the Want of a COUNT"></a>For the Want of a <code>COUNT</code></h2><p>Today I found myself with the problem of executing a <code>COUNT</code> query with a simple <code>WHERE</code> clause on a large table. The user wanted to get an idea of how many rows were of a particular type, but wanted to do so within the course of a page load. The result didn’t have to be exact, but it did have to give a rough idea of how large the <em>real</em> number of rows in the result were. The <code>COUNT</code> query was taking over a minute to execute (which is well past the threshold of what I wanted in the flow of a web request), so I decided to investigate ways of getting a “close enough” answer in less time.</p><p>There’s a few different ways to approach a problem like this, but many of those approaches involve some level of pre-calculation or caching (such as materialized views or using sequences). I didn’t want to give such a simple query the overhead of an external process, and I’m usually averse to database triggers when they aren’t standard in a database already. I needed a way to estimate the result of my query entirely within a single request flow.</p><h2 id="Ab-using-EXPLAIN"><a href="#Ab-using-EXPLAIN" class="headerlink" title="(Ab)using EXPLAIN"></a>(Ab)using <code>EXPLAIN</code></h2><p>After some googling I came across <a href="https://www.citusdata.com/blog/2016/10/12/count-performance" target="_blank" rel="noopener">this excellent article by Citus Data</a>, which goes over strategies for efficently calculating and estimating counts on large tables. If your use case is in any way different than mine, I would suggest consulting that article first for a solution that better fits your needs. In it they cite an old trick for getting a rough estimate of the outcome of a query: Parsing the output of the <code>EXPLAIN</code> command.</p><p>For those not familiar, <code>EXPLAIN</code> is PostgreSQL’s way of letting you know how it plans to execute your query. By itself it’s an excellent tool for debugging long running queries and finding ways of speeding them up. Without adding the keyword <code>ANALYZE</code>, it doesn’t actually perform your query, it only exposes how it <em>plans</em> to get the result. PostgreSQL uses a set of <a href="https://www.postgresql.org/docs/10/row-estimation-examples.html" target="_blank" rel="noopener">clever techniques</a> to estimate the impact of an action before it performs it, which is necessary for the query to be executed efficiently. </p><p>This is great for us, since it means that a highly supported and optomized portion of PostgreSQL is already doing the work of estimating the cost of each part of our query. We just need to glean the number of rows it thinks will be returned:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> count_estimate(<span class="keyword">query</span> <span class="built_in">text</span>) <span class="keyword">RETURNS</span> <span class="built_in">integer</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    rec   <span class="built_in">record</span>;</span><br><span class="line">    rows  integer;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">FOR</span> rec <span class="keyword">IN</span> <span class="keyword">EXECUTE</span> <span class="string">'EXPLAIN '</span> || <span class="keyword">query</span> <span class="keyword">LOOP</span></span><br><span class="line">        <span class="keyword">rows</span> := <span class="keyword">substring</span>(rec.<span class="string">"QUERY PLAN"</span> <span class="keyword">FROM</span> <span class="string">' rows=([[:digit:]]+)'</span>);</span><br><span class="line">        EXIT WHEN rows IS NOT NULL;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"></span><br><span class="line">    RETURN rows;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql VOLATILE STRICT;</span><br></pre></td></tr></table></figure><p><em><a href="https://www.postgresql.org/message-id/20050810133157.GA46247@winnie.fuhr.org" target="_blank" rel="noopener">Credit to Mike Fuhr</a> for authoring and posting this to the PostgreSQL mailing list.</em></p><p>Note that in order to use this function we need to pass in our query as text. Depending on how you invoke your SQL queries, that may put an upper limit on how complex of a query you want to feed into this function. Given that the resulting estimate will vary more widely the more complex your query is, being constrained to small and simple queries could be a good thing.</p><h2 id="Testing-the-Happy-Path"><a href="#Testing-the-Happy-Path" class="headerlink" title="Testing the Happy Path"></a>Testing the Happy Path</h2><p>Using a table of about 52 million rows, I ran a benchmark to see how much of a difference using estimates would make. (All row numbers below have been slightly fuzzed but ratios have been preserved).</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Control</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> large_table <span class="keyword">WHERE</span> condition;</span><br></pre></td></tr></table></figure><p>Running the above returns a count of 52,652,307 rows in 1m:24s. Longer than I’d want to wait around for a result, but it’s a big table.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Experimental</span></span><br><span class="line"><span class="keyword">SELECT</span> count_estimate(</span><br><span class="line">  <span class="string">'SELECT * FROM large_table WHERE condition'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Running this returns a count of 52,234,432 rows in only took 0.081s. That’s <em>much</em> faster:</p><ul><li>Difference in result:     <strong>0.8%</strong></li><li>Difference in runtime:    <strong>103,704%</strong></li></ul><p>1037 times the speed in exchange for about a 1% loss in accuracy sounds like a good deal to me.</p><h2 id="Potential-Pitfalls"><a href="#Potential-Pitfalls" class="headerlink" title="Potential Pitfalls"></a>Potential Pitfalls</h2><p>But wait, it’s not all sunshine and roses. While most of the tests I performed on large tables behaved similarly, there was one case where this form of table estimation did not shine: Shrinking tables.</p><p>Let’s take a look at a small table on my system that’s been emptied out for this test:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> small_table;</span><br><span class="line"><span class="comment">-- Result: 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> count_estimate(</span><br><span class="line">  <span class="string">'SELECT * FROM small_table'</span></span><br><span class="line">); </span><br><span class="line"><span class="comment">-- Result: 960</span></span><br></pre></td></tr></table></figure><p>Wow, that’s way off! What happened to my 1% accuracy margin? </p><p>Maybe it’s just an issue with a table with 0 rows. What would happen if I were to add 10 rows to my empty table? Would my estimate change?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> small_table (,,,) <span class="keyword">VALUES</span> (,,,), (,,,), ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> small_table;</span><br><span class="line"><span class="comment">-- Result: 10 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> count_estimate(</span><br><span class="line">  <span class="string">'SELECT * FROM small_table'</span></span><br><span class="line">); </span><br><span class="line"><span class="comment">-- Result: 960</span></span><br></pre></td></tr></table></figure><p>Hmm, no change. Where does 960 come from? Let’s go back to that list of <a href="https://www.postgresql.org/docs/10/row-estimation-examples.html" target="_blank" rel="noopener">clever techniques</a> in the PostgreSQL docs…</p><blockquote><p>The number of pages and rows is looked up in pg_class… These numbers are current as of the last VACUUM or ANALYZE on the table. The planner then fetches the actual current number of pages in the table (this is a cheap operation, not requiring a table scan). If that is different from relpages then reltuples is scaled accordingly to arrive at a current number-of-rows estimate.</p></blockquote><p>OK, so what happens if call <code>VACUUM</code> beforehand?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VACUUM small_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> small_table;</span><br><span class="line"><span class="comment">-- 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> count_estimate(</span><br><span class="line">  <span class="string">'SELECT * FROM small_table'</span></span><br><span class="line">); </span><br><span class="line"><span class="comment">-- 10</span></span><br></pre></td></tr></table></figure><p>That’s more like it.</p><p>Turns out 960 is the number of rows this table had since the last time it was <code>VACUUM</code>ed. This wouldn’t have been a problem if the table grew steadily, but since it was cleared right before testing PostgreSQL didn’t get the chance to clean up enough for the estimate to be accurate.</p><p>While this may seem like an edge case, I believe it’s worth knowing about if you want your estimate to be up to date. Particularly if the table your estimating has a chance of going to zero rows.</p><p>While we could just <code>VACUUM</code> before performing our query, I don’t know that doing this automatically every time we want an estimate is the best use of PostgreSQL’s resources.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>If you have a massive table and that does have rows regularly added or deleted in significant quantities, using the above <code>count_estimate</code> function could save you a lot of time and resources.</li><li><strong>But</strong> if your table has rows added and/or deleted in quantities you would care to see reflected quickly in an estimate and you’d rather not manually <code>VACUUM</code>, use another technique.</li></ul><h3 id="Further-Reading"><a href="#Further-Reading" class="headerlink" title="Further Reading"></a>Further Reading</h3><ul><li><a href="https://www.citusdata.com/blog/2016/10/12/count-performance#dup_counts_estimated_filtered" target="_blank" rel="noopener">“Faster PostgreSQL Counting” - citusdata.com</a></li><li><a href="https://www.postgresql.org/docs/10/row-estimation-examples.html" target="_blank" rel="noopener">“Row Estimation Examples” - postgresql.org</a></li><li><a href="https://www.postgresql.org/message-id/20050810133157.GA46247@winnie.fuhr.org" target="_blank" rel="noopener">“Re: **SPAM** Faster count(*)?” - postgresql.org</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> postgreSQL sql code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/articles/2019-02-24-hello-world/"/>
      <url>/articles/2019-02-24-hello-world/</url>
      
        <content type="html"><![CDATA[<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> post = getBlogPost();</span><br><span class="line">    blog.write(post);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBlogPost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Welcome to my blog! Not entirely sure what this should be about yet, but I had a free Sunday afternoon and figured it was about time I put together a site.</p><p>I doubt that I’ll be making any major posts to this site any time soon, but to kick things off I thought it may be helpful to discuss how the site was made in thanks to the excellent open source tools I used.</p><ul><li><a href="https://hexo.io/" target="_blank" rel="noopener"><strong>Hexo</strong></a> - Excellent blogging framework that uses a node js stack. It’s not the simplest program out there, but I’m familiar with the tech stack and can customize it just deeply enough to make it my own.</li><li><a href="https://github.com/probberechts/hexo-theme-cactus" target="_blank" rel="noopener"><strong>Cactus</strong></a> - Hexo theme with a few color options. I simplified some of the layouts and changed some colors, but what remains is mostly faithful to the original design. Thanks to <a href="https://github.com/probberechts" target="_blank" rel="noopener">Pieter Robberechts</a> for the excellent design.</li><li><a href="https://pages.github.com/" target="_blank" rel="noopener"><strong>Github Pages</strong></a> - Simple and free static site hosting straight from Github. Hexo has the ability to deploy the rendered site via git, and Github is more than willing to accept pushes to deploy.</li><li><a href="https://www.npmjs.com/package/hexo-generator-search" target="_blank" rel="noopener"><strong>hexo-generator-search</strong></a> - A local search generator for hexo that makes instant searches work on a static site. Props for the smooth integration with Cactus.</li></ul><p>Test testerson</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
